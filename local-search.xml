<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis缓存</title>
    <link href="/2023/04/26/Redis%E7%BC%93%E5%AD%98/"/>
    <url>/2023/04/26/Redis%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h4 id="缓存定义"><a href="#缓存定义" class="headerlink" title="缓存定义"></a>缓存定义</h4><p><strong>缓存(<strong>Cache),就是数据交换的</strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码，读写性能较高。</p><h4 id="为什么要使用缓存"><a href="#为什么要使用缓存" class="headerlink" title="为什么要使用缓存"></a>为什么要使用缓存</h4><p>一句话:因为<strong>速度快,好用</strong></p><p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p><p>实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为”避震器”,系统是几乎撑不住的,所以企业会大量运用到缓存技术。但是缓存也会增加代码复杂度和运营的成本。</p><h4 id="如何使用缓存"><a href="#如何使用缓存" class="headerlink" title="如何使用缓存"></a>如何使用缓存</h4><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p><p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p><p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p><p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p><p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p><p><strong>在使用redis开发的过程中，缓存穿透、击穿、雪崩等是很难避免的问题。也是在面试过程中经常被问到的问题，今天将分别讲解这三类问题，以及多种解决方案。</strong></p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h4><p>缓存击穿是指一个Key非常热点，在某些时间点被超高并发地访问，当这个Key在失效的瞬间持续的大并发穿破了缓存(Redis)直接请求到数据库(DB)从而导致数据库出现问题。</p><p><strong>解决方案一：使用互斥锁</strong></p><p>这种解决方案思路比较简单，就是只让一个线程查询数据库，其它线程等待查询数据库的线程执行完毕并且重新将数据加入缓存，其它线程从缓存获取数据就可以了。</p><p>如果是单机系统，可以用synchronized或者lock来处理。分布式系统可以用redis的setnx操作。</p><p>单机环境</p><ul><li>单机环境中实现的原理大概就是当缓存数据过期后，大量请求进来，只有首个线程可以访问数据库其它线程暂停等主线程查询到数据并释放了锁，其它线程就可以直接在缓存中读取数据了。</li></ul><p><img src="p1.png" alt="Redis缓存"></p><p>分布式环境</p><ul><li>在缓存失效的时候先判断拿出来的值为空，不是立即去查库，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的setnx），去set一个mutex key，当操作返回成功时，再进行查库操作并回设缓存。否则，就重试整个get缓存的方法。</li></ul><p><img src="p2.png" alt="Redis缓存"></p><p><strong>解决方案二：热点数据永不过期</strong></p><p>要值得注意的是，这里说到的永不过期并不是将热点数据存在时间设置为无限制。而是将过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的重建。</p><p><img src="p3.png" alt="Redis缓存"></p><p>从实战看，这种方法对于性能非常友好，唯一不足的就是重建缓存时候，其余线程(非重建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。</p><p><img src="p4.png" alt="Redis缓存"></p><p><strong>解决方案三：定时刷新</strong></p><p>后台定义一个job(定时任务)专门主动更新缓存数据，比如一个缓存中的数据过期时间是30分钟,那么job每隔29分钟定时刷新数据(将从数据库中查到的数据更新到缓存中)。</p><p>这种方案比较容易理解，但会增加系统复杂度。比较适合那些 key 相对固定。缓存粒度较大的业务，key比较分散的则不太适合，实现起来也比较复杂。</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h4><p>缓存穿透是指用户恶意的发起大量请求去查询一个缓存(Redis)和数据库(DB)中都没有的数据，出于容错考虑从数据库(DB)查不到数据则不写入缓存(Redis)这将导致每个请求都要到数据库(DB)中查询，失去了缓存的意义，从而导致数据库因压力过大挂掉。</p><p><img src="p5.png" alt="Redis缓存"></p><p><strong>解决方案一：对空数据进行缓存</strong></p><p>对空数据进行缓存是一个简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><p>这种办法虽然能阻挡大量穿透请求，但是这个空值不具有任何实际业务性，而且如果大量发送获取不存在数据的穿透请求的话（例如恶意攻击），则会浪费缓存空间，如果这种null值过量的话，还会淘汰掉本身缓存存在的数据，这就会使我们的缓存命中率下降。</p><p><img src="p6.png" alt="Redis缓存"></p><p><strong>解决方案二：布隆过滤器</strong></p><p>这种技术在缓存之前再加一层屏障，里面存储目前数据库中存在的所有key。当业务系统有查询请求的时候，首先去BloomFilter中查询该key是否存在。若不存在，则说明数据库中也不存在该数据，因此缓存都不要查了，直接返回null。若存在，则继续执行后续的流程，先前往缓存中查询，缓存中没有的话再前往数据库中的查询。</p><p><img src="p7.png" alt="Redis缓存"></p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h4><p>缓存雪崩是指缓存服务器重启或缓存(Redis)中的数据在同一时间内大批量过期，因查询数据量太大引起数据库压力过大甚至宕机。</p><p><strong>解决方案一：加锁排队</strong></p><p>加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法！</p><p>注意：在高并发场景下尽可能不用！</p><p><img src="p8.png" alt="Redis缓存"></p><p><strong>解决方案二：设置过期时间随机值</strong></p><p>避免缓存设置相近的有效期，为有效期增加随机值(1-5分钟)使失效时间均匀分布。这样每一个缓存的过期时间的重复率就会降低，很难引发集体失效的事件。</p><p><img src="p9.png" alt="Redis缓存"></p><p><strong>解决方案三：设置过期标志更新缓存</strong></p><p>缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存；</p><p>缓存数据：它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。</p><p><img src="p10.png" alt="Redis缓存"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p><strong>缓存击穿</strong></p><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。一般通过互斥锁，热点数据永不过期，定时刷新过期时间等方法解决该问题。</p><p><strong>缓存穿透</strong></p><p>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。一般通过对空数据进行缓存，布隆过滤器等方法解决该问题。</p><p><strong>缓存雪崩</strong></p><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。一般通过加锁排队，设置过期时间随机值等方法解决该问题。</p><p>博客参考微信公众号  大厂面试题 《扒一扒Redis，缓存击穿，缓存穿透，缓存雪崩，附解决方案》。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nosql</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电脑商城03</title>
    <link href="/2023/04/26/%E7%94%B5%E8%84%91%E5%95%86%E5%9F%8E03/"/>
    <url>/2023/04/26/%E7%94%B5%E8%84%91%E5%95%86%E5%9F%8E03/</url>
    
    <content type="html"><![CDATA[<p>1.登录-持久层<br>规划需要执行的SQL语句</p><p>依据用户提交的用户名来做select查询</p><p>select * from t_user where username=? and password=?这种不太好,这种相当于在查询用户名时直接判断了用户和密码是否一致了,如果持久层把判断做了那业务层就没事干了,所以这里我们只查询用户名,判断用户名和密码是否一致交给业务层做</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> username<span class="hljs-operator">=</span>?<br></code></pre></td></tr></table></figure><p>分析完以后发现这个功能模块已经被开发完成(UserMapper接口的findByUsername方法),所以就可以省略当前的开发步骤,但是这个分析过程不能省略.后续的设计接口和抽象方法,编写映射,单元测试都不再需要进行,</p><h3 id="2-登录-业务层"><a href="#2-登录-业务层" class="headerlink" title="2.登录-业务层"></a>2.登录-业务层</h3><h4 id="2-1规划异常"><a href="#2-1规划异常" class="headerlink" title="2.1规划异常"></a>2.1规划异常</h4><ul><li>用户名对应的密码错误,即密码匹配的异常,起名PasswordNotMatchException,这个是运行时异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PasswordNotMatchException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceException</span>&#123;<br>    <span class="hljs-comment">/**重写ServiceException的所有构造方法*/</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>用户名没有被找到的异常,起名UsernameNotFoundException,这个也是运行时异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UsernameNotFoundException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceException</span> &#123;<br>    <span class="hljs-comment">/**重写ServiceException的所有构造方法*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2设计接口和抽象方法及实现"><a href="#2-2设计接口和抽象方法及实现" class="headerlink" title="2.2设计接口和抽象方法及实现"></a>2.2设计接口和抽象方法及实现</h4><p>1.在IUserService接口中编写抽象方法login(String username,String password)login(User user)也是可以的</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">细说一个事:登录成功某一个网站后,右上角会展示头像,昵称甚至电话号码等等,这些信息依赖于登陆成功后的信息,也就意味着一旦登录成功后在页面中切换到任意一个子页面写右上角都会展示这些信息.本质上就是查询出来这些信息,然后展示在右上角,但是这里实现查询不太现实:js中虽然打开一个html页面就自动发送一个请求,但这样就需要把这个查询的代码写在每一个html页面,显然不现实.<br><br>这种情况下我们可以将当前登录成功的用户数据以当前用户对象的形式进行返回,然后进行状态管理:将数据保存在cookie或者session中,可以避免重复度很高的数据多次频繁操作数据库进行获取(这里我们用session存放用户名和用户<span class="hljs-built_in">id</span>,用cookie存放用户头像,其中用户<span class="hljs-built_in">id</span>是为因为有的页面展示依赖于<span class="hljs-built_in">id</span>,用户头像也可以放在session中,而这里放在cookie是为了回顾一下cookie)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户登录功能</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> password 用户密码</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 当前匹配的用户数据,如果没有则返回null</span><br><span class="hljs-comment"> */</span><br>User <span class="hljs-title function_">login</span><span class="hljs-params">(String username,String password)</span>;<br><br></code></pre></td></tr></table></figure><p>2.在抽象类UserServiceImpl中实现该抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">login</span><span class="hljs-params">(String username, String password)</span> &#123;<br>    <span class="hljs-comment">//根据用户名称来查询用户的数据是否存在,不存在则抛出异常</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.findByUsername(username);<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(<span class="hljs-string">&quot;用户数据不存在&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检测用户的密码是否匹配:</span><br><span class="hljs-comment">     * 1.先获取数据库中加密之后的密码</span><br><span class="hljs-comment">     * 2.和用户传递过来的密码进行比较</span><br><span class="hljs-comment">     *  2.1先获取盐值</span><br><span class="hljs-comment">     *  2.2将获取的用户密码按照相同的md5算法加密</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">oldPassword</span> <span class="hljs-operator">=</span> result.getPassword();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">salt</span> <span class="hljs-operator">=</span> result.getSalt();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">newMd5Password</span> <span class="hljs-operator">=</span> getMD5Password(password, salt);<br>    <span class="hljs-keyword">if</span> (!newMd5Password.equals(oldPassword)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PasswordNotMatchException</span>(<span class="hljs-string">&quot;用户密码错误&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//判断is_delete字段的值是否为1,为1表示被标记为删除</span><br>    <span class="hljs-keyword">if</span> (result.getIsDelete() == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(<span class="hljs-string">&quot;用户数据不存在&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//方法login返回的用户数据是为了辅助其他页面做数据展示使用(只会用到uid,username,avatar)</span><br>    <span class="hljs-comment">//所以可以new一个新的user只赋这三个变量的值,这样使层与层之间传输时数据体量变小,后台层与</span><br>    <span class="hljs-comment">// 层之间传输时数据量越小性能越高,前端也是的,数据量小了前端响应速度就变快了</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setUid(result.getUid());<br>    user.setUsername(result.getUsername());<br>    user.setAvatar(result.getAvatar());<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3单元测试"><a href="#2-3单元测试" class="headerlink" title="2.3单元测试"></a>2.3单元测试</h4><p>在业务层的测试类UserServiceTests中添加测试方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//因为login方法可能抛出异常,所以应该捕获异常,但是测试时没必要写那么严谨</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.login(<span class="hljs-string">&quot;test02&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>);<br>    System.out.println(user);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-登录-控制层"><a href="#3-登录-控制层" class="headerlink" title="3.登录-控制层"></a>3.登录-控制层</h3><h4 id="3-1处理异常"><a href="#3-1处理异常" class="headerlink" title="3.1处理异常"></a>3.1处理异常</h4><p>业务层抛出的异常需要在统一异常处理类中进行统一的捕获和处理,如果该异常类型已经在统一异常类中曾经处理过则不需要重复添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> UsernameNotFoundException) &#123;<br>    result.setState(<span class="hljs-number">4001</span>);<br>    result.setMessage(<span class="hljs-string">&quot;用户数据不存在的异常&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> PasswordNotMatchException) &#123;<br>    result.setState(<span class="hljs-number">4002</span>);<br>    result.setMessage(<span class="hljs-string">&quot;用户名密码错误的异常&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>3.2设计请求</p><pre><code class="hljs">请求路径:/users/login请求参数:String username,String password请求类型:POST响应结果:JsonResult&lt;User&gt;</code></pre><p>3.3处理请求</p><p>在UserController类中编写处理请求的方法.编写完成后启动主服务验证一下.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;login&quot;)</span><br><span class="hljs-keyword">public</span> JsonResult&lt;User&gt; <span class="hljs-title function_">login</span><span class="hljs-params">(String username,String password)</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> userService.login(username, password);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonResult</span>&lt;User&gt;(OK,data);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意,控制层方法的参数是用来接收前端数据的,接收数据方式有两种:</p><ul><li>请求处理方法的参数列表设置为非pojo类型:</li></ul><p>SpringBoot会直接将请求的参数名和方法的参数名直接进行比较,如果名称相同则自动完成值的依赖注入</p><ul><li>请求处理方法的参数列表设置为pojo类型:</li></ul><p>SpringBoot会将前端的url地址中的参数名和pojo类的属性名进行比较,如果这两个名称相同,则将值注入到pojo类中对应的属性上</p><p>这两种方法都没有使用注解等等花里胡哨的,却能正常使用,原因是springboot是约定大于配置的,省略了大量配置以及注解的编写.</p><h3 id="4-登录-前端页面"><a href="#4-登录-前端页面" class="headerlink" title="4.登录-前端页面"></a>4.登录-前端页面</h3><p>在login.html加入script标签:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    $(<span class="hljs-string">&quot;#btn-login&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        $.<span class="hljs-title function_">ajax</span>(&#123;<br>            <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/users/login&quot;</span>,<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;POST&quot;</span>,<br>            <span class="hljs-attr">data</span>: $(<span class="hljs-string">&quot;#form-login&quot;</span>).<span class="hljs-title function_">serialize</span>(),<br>            <span class="hljs-attr">dataType</span>: <span class="hljs-string">&quot;JSON&quot;</span>,<br>            <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">json</span>) &#123;<br>                <span class="hljs-keyword">if</span> (json.<span class="hljs-property">state</span> == <span class="hljs-number">200</span>) &#123;<br>                    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;登录成功&quot;</span>)<br>                    <span class="hljs-comment">//跳转到系统主页index.html</span><br>                    <span class="hljs-comment">//index和login在同一个目录结构下,所以可以用相对路</span><br>                    <span class="hljs-comment">// 径index.html来确定跳转的页面,index.html和./ind</span><br>                    <span class="hljs-comment">// ex.html完全一样,因为./就是表示当前目录</span><br>                    <span class="hljs-comment">// 结构,也可以用../web/index.html</span><br>                    location.<span class="hljs-property">href</span> = <span class="hljs-string">&quot;index.html&quot;</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;登录失败&quot;</span>)<br>                &#125;<br>            &#125;,<br>            <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) &#123;<br>                <span class="hljs-comment">//xhr.message可以获取未知异常的信息</span><br>                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;登录时产生未知的异常!&quot;</span>+xhr.<span class="hljs-property">message</span>);<br>            &#125;<br>        &#125;);<br>    &#125;);<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><p>5.用session存储和获取用户数据</p><pre><code class="hljs">在用户登录成功后要保存下来用户的id,username,avatar,并且需要在任何类中都可以访问存储下来的数据,也就是说存储在一个全局对象中,会话session可以实现把首次登录所获取的用户数据转移到session对象即可获取session对象的属性值用session.getAttribute(“key”),因为session对象的属性值在很多页面都要被访问,这时用session对象调用方法获取数据就显得太麻烦了,解决办法是将获取session中数据的这种行为进行封装考虑一下封装在哪里呢?放在一个干净的工具类里肯定可以,但就这个项目目录结构而言,只有可能在控制层使用session,而控制层里的类又继承BaseController,所以可以封装到BaseController里面</code></pre><p>综上所述,该功能的实现需要两步:</p><p>1.在父类中封装两个方法:获取uid和获取username对应的两个方法(用户头像暂不考虑,将来封装到cookie中来使用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取session对象中的uid</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> session session对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 当前登录的用户uid的值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Integer <span class="hljs-title function_">getUidFromSession</span><span class="hljs-params">(HttpSession session)</span> &#123;<br>    <span class="hljs-comment">//getAttribute返回的是Object对象,需要转换为字符串再转换为包装类</span><br>    <span class="hljs-keyword">return</span> Integer.valueOf(session.getAttribute(<span class="hljs-string">&quot;uid&quot;</span>).toString());<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">getUsernameFromSession</span><span class="hljs-params">(HttpSession session)</span> &#123;<br>    <span class="hljs-keyword">return</span> session.getAttribute(<span class="hljs-string">&quot;username&quot;</span>).toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>2.把首次登录所获取的用户数据转移到session对象:</p><p>服务器本身自动创建有session对象,已经是一个全局的session对象,所以我们需要想办法获取session对象:如果直接将HttpSession类型的对象作为请求处理方法的参数,这时springboot会自动将全局的session对象注入到请求处理方法的session形参上:</p><ul><li><p>将登录模块的设计请求中的请求参数:String username,String password加上HttpSession session</p></li><li><p>将登录模块的处理请求中login方法加上参数HttpSession session并修改代码如下:</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;login&quot;)</span><br><span class="hljs-keyword">public</span> JsonResult&lt;User&gt; <span class="hljs-title function_">login</span><span class="hljs-params">(String username, String password, HttpSession session)</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> userService.login(username, password);<br><br>    <span class="hljs-comment">//向session对象中完成数据的绑定(这个session是全局的,项目的任何位置都可以访问)</span><br>    session.setAttribute(<span class="hljs-string">&quot;uid&quot;</span>,data.getUid());<br>    session.setAttribute(<span class="hljs-string">&quot;username&quot;</span>,data.getUsername());<br><br>    <span class="hljs-comment">//测试能否正常获取session中存储的数据</span><br>    System.out.println(getUidFromSession(session));<br>    System.out.println(getUsernameFromSession(session));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonResult</span>&lt;User&gt;(OK,data);<br>&#125;<br></code></pre></td></tr></table></figure><p>6.拦截器</p><pre><code class="hljs">拦截器的作用是将所有的请求统一拦截到拦截器中,可以在拦截器中定义过滤的规则,如果不满足系统设置的过滤规则,该项目统一的处理是重新去打开login.html页面(重定向和转发都可以,推荐使用重定向)拦截器在springboot中本质是依靠springMVC完成的.springMVC提供了一个HandlerInterceptor接口用于表示定义一个拦截器</code></pre><p>1.所以想要使用拦截器就要定义一个类并使其实现HandlerInterceptor接口,在store下建包interceptor,包下建类LoginInterceptor并编写代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**定义一个拦截器*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *检测全局session对象中是否有uid数据,如果有则放行,如果没有重定向到登录页面</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request 请求对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response 响应对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler 处理器(把url和Controller映射到一块)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回值为true放行当前请求,反之拦截当前请求</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//在DispatcherServlet调用所有处理请求的方法前被自动调用执行的方法</span><br>    <span class="hljs-comment">//springboot会自动把请求对象给到request,响应对象给到response,适配器给到handler</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, </span><br><span class="hljs-params">                             HttpServletResponse response, </span><br><span class="hljs-params">                             Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//通过HttpServletRequest对象来获取session对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> request.getSession().getAttribute(<span class="hljs-string">&quot;uid&quot;</span>);<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//说明用户没有登录过系统,则重定向到login.html页面</span><br>            <span class="hljs-comment">//不能用相对路径,因为这里是要告诉前端访问的新页面是在哪个目录下的新</span><br>            <span class="hljs-comment">//页面,但前面的localhost:8080可以省略,因为在同一个项目下</span><br>            response.sendRedirect(<span class="hljs-string">&quot;/web/login.html&quot;</span>);<br>            <span class="hljs-comment">//结束后续的调用</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//放行这个请求</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//在ModelAndView对象返回给DispatcherServlet之后被自动调用的方法</span><br><span class="hljs-comment">//    @Override</span><br><span class="hljs-comment">//    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="hljs-comment">//    &#125;</span><br>    <span class="hljs-comment">//在整个请求所有关联的资源被执行完毕后所执行的方法</span><br><span class="hljs-comment">//    @Override</span><br><span class="hljs-comment">//    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="hljs-comment">//    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2.注册过滤器:</p><p>注册过滤器的技术:借助WebMvcConfigure接口将用户定义的拦截器进行注册.所以想要注册过滤器需要定义一个类使其实现WebMvcConfigure接口并在其内部添加黑名单(在用户登录的状态下才可以访问的页面资源)和白名单(哪些资源可以在不登录的情况下访问:①register.html②login.html③index.html④/users/reg⑤/users/login⑥静态资源):</p><pre><code class="hljs">WebMvcConfigure是配置信息,建议在store包下建config包,再定义类LoginInterceptorConfigure</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**拦截器的注册*/</span><br><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//自动加载当前的类并进行拦截器的注册,如果没有@Configuration就相当于没有写类LoginInterceptorConfigure</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptorConfigure</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//配置拦截器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//1.创建自定义的拦截器对象</span><br>        <span class="hljs-type">HandlerInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>();<br>        <span class="hljs-comment">//2.配置白名单并存放在一个List集合</span><br>        List&lt;String&gt; patterns = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        patterns.add(<span class="hljs-string">&quot;/bootstrap3/**&quot;</span>);<br>        patterns.add(<span class="hljs-string">&quot;/css/**&quot;</span>);<br>        patterns.add(<span class="hljs-string">&quot;/images/**&quot;</span>);<br>        patterns.add(<span class="hljs-string">&quot;/js/**&quot;</span>);<br>        patterns.add(<span class="hljs-string">&quot;/web/register.html&quot;</span>);<br>        patterns.add(<span class="hljs-string">&quot;/web/login.html&quot;</span>);<br>        patterns.add(<span class="hljs-string">&quot;/web/index.html&quot;</span>);<br>        patterns.add(<span class="hljs-string">&quot;/web/product.html&quot;</span>);<br>        patterns.add(<span class="hljs-string">&quot;/users/reg&quot;</span>);<br>        patterns.add(<span class="hljs-string">&quot;/users/login&quot;</span>);<br><br>        <span class="hljs-comment">//registry.addInterceptor(interceptor);完成拦截</span><br>        <span class="hljs-comment">// 器的注册,后面的addPathPatterns表示拦截哪些url</span><br>        <span class="hljs-comment">//这里的参数/**表示所有请求,再后面的excludePathPatterns表</span><br>        <span class="hljs-comment">// 示有哪些是白名单,且参数是列表</span><br>        registry.addInterceptor(interceptor)<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .excludePathPatterns(patterns);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>电脑商城</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSM</tag>
      
      <tag>项目练习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电脑商城02</title>
    <link href="/2023/04/26/%E7%94%B5%E8%84%91%E5%95%86%E5%9F%8E02/"/>
    <url>/2023/04/26/%E7%94%B5%E8%84%91%E5%95%86%E5%9F%8E02/</url>
    
    <content type="html"><![CDATA[<h2 id="用户注册功能"><a href="#用户注册功能" class="headerlink" title="用户注册功能"></a>用户注册功能</h2><h3 id="1-创建数据表"><a href="#1-创建数据表" class="headerlink" title="1.创建数据表"></a>1.创建数据表</h3><p>1.选中数据表:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">use store<br></code></pre></td></tr></table></figure><p>2.创建t_user表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_user (<br>uid <span class="hljs-type">INT</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;用户id&#x27;</span>,<br>username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span> COMMENT <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>`password` <span class="hljs-type">CHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;密码&#x27;</span>,<br>salt <span class="hljs-type">CHAR</span>(<span class="hljs-number">36</span>) COMMENT <span class="hljs-string">&#x27;盐值&#x27;</span>,<br>phone <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) COMMENT <span class="hljs-string">&#x27;电话号码&#x27;</span>,<br>email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) COMMENT <span class="hljs-string">&#x27;电子邮箱&#x27;</span>,<br>gender <span class="hljs-type">INT</span> COMMENT <span class="hljs-string">&#x27;性别:0-女，1-男&#x27;</span>,<br>avatar <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) COMMENT <span class="hljs-string">&#x27;头像&#x27;</span>,<br>is_delete <span class="hljs-type">INT</span> COMMENT <span class="hljs-string">&#x27;是否删除：0-未删除，1-已删除&#x27;</span>,<br>created_user <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) COMMENT <span class="hljs-string">&#x27;日志-创建人&#x27;</span>,<br>created_time DATETIME COMMENT <span class="hljs-string">&#x27;日志-创建时间&#x27;</span>,<br>modified_user <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) COMMENT <span class="hljs-string">&#x27;日志-最后修改执行人&#x27;</span>,<br>modified_time DATETIME COMMENT <span class="hljs-string">&#x27;日志-最后修改时间&#x27;</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY (uid)<br>) ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><p>注册页面的确认密码功能多数开发中交给前端做,如果两次密码输入不同就不能将数据传给后台</p></li><li><p>创建t-user表时<code>password</code> CHAR(32) NOT NULL COMMENT ‘密码’,因为password是关键字,所以需要用<code>号(不是单引号,是esc下面的那个键)并且后面用到该字段时(比如往表中插入数据)也需要用</code></p></li><li><p>创建t_user表时salt CHAR(36) COMMENT ‘盐值’,是为了在用户注册时对用户的密码进行加密操作(后续再讲)</p></li><li><p>数据库中的性别0代表女,1代表男,数据库中用数字而不是文字是因为前端的性别选项是单选框,提交给后台的是数字</p></li><li><p>创建t_user表时is_delete INT COMMENT ‘是否删除：0-未删除，1-已删除’,的作用:网站中都有注销账号的功能,大部分的网站并不是真的将用户注销了,而是在下次用户登录时进行验证,如果是0就放行,如果是1就禁止登录</p></li><li><p>创建t-user表时username VARCHAR(20) NOT NULL UNIQUE COMMENT ‘用户名’,的UNIQUE 作为约束条件使用户名唯一</p></li><li><p>将来任何一张表都有以下四个字段:</p></li></ul><p>​        created_user VARCHAR(20) COMMENT ‘创建人’,</p><p>​        created_time DATETIME COMMENT ‘创建时间’,</p><p>​        modified_user VARCHAR(20) COMMENT ‘修改人’,</p><p>​        modified_time DATETIME COMMENT ‘修改时间’,</p><p>​        所以为了开发方便可以把这四个字段作为整个实体类</p><h3 id="2-创建用户的实体类"><a href="#2-创建用户的实体类" class="headerlink" title="2.创建用户的实体类"></a>2.创建用户的实体类</h3><p>1.通过表的结构提取出表的公共字段,放在一个实体类的基类中,起名BaseEntity基类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseEntity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> String createdUser;<br>    <span class="hljs-keyword">private</span> Date createdTime;<br>    <span class="hljs-keyword">private</span> String modifiedUser;<br>    <span class="hljs-keyword">private</span> Date emodifiedTime;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * get,set</span><br><span class="hljs-comment"> * equals和hashCode</span><br><span class="hljs-comment"> * toString</span><br><span class="hljs-comment"> */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2.创建用户的实体类,并使其继承BaseEntity基类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseEntity</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer uid;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String PASSWORD;<br>    <span class="hljs-keyword">private</span> String salt;<br>    <span class="hljs-keyword">private</span> String phone;<br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-keyword">private</span> Integer gender;<br>    <span class="hljs-keyword">private</span> String avatar;<br>    <span class="hljs-keyword">private</span> Integer isDelete;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * get,set</span><br><span class="hljs-comment"> * equals和hashCode</span><br><span class="hljs-comment"> * toString</span><br><span class="hljs-comment"> */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><p>实体类User因为要在网络中以流的形式传输,所以需要serialize序列化(但因为其继承的父类BaseEntity已经实现序列化,所以就不需要再写implements Serializable)</p></li><li><p>实体类BaseEntity中自动导入Getter and Setter方法,euqals()方法,hashCode()方法,toString方法,其中euqals()方法,hashCode()方法自动导入步骤:</p><p>  enter+insert<br>  点击euqals() and hashCode()<br>  勾选Accept…和Use这两段话,并且选择Template为IntelliJ Default<br>  一路next到底</p></li><li><p>ssm框架开发项目的时候需要在实体类上面加@Component然后spring才能自动进行对象的创建维护,而springboot不再需要,因为springboot遵循的原则是约定大于配置,如果字段名称相同那就可以自动完成字段的初始化</p></li></ul><h3 id="3-注册-持久层"><a href="#3-注册-持久层" class="headerlink" title="3.注册-持久层"></a>3.注册-持久层</h3><p>通过Mybatis来操作数据库,也就是在做mybatis开发的流程</p><h4 id="3-1规划需要执行的SQL语句"><a href="#3-1规划需要执行的SQL语句" class="headerlink" title="3.1规划需要执行的SQL语句"></a>3.1规划需要执行的SQL语句</h4><p>1.用户的注册功能,从后端持久层来看相当于在做数据的插入操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">inser <span class="hljs-keyword">into</span> t_user (username)<br></code></pre></td></tr></table></figure><p>2.在用户的注册时首先要去查询当前的用户名是否存在,如果存在则不能进行注册,相当于是一条查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> username<span class="hljs-operator">=</span>?<br></code></pre></td></tr></table></figure><h4 id="3-2设计接口和抽象方法及实现"><a href="#3-2设计接口和抽象方法及实现" class="headerlink" title="3.2设计接口和抽象方法及实现"></a>3.2设计接口和抽象方法及实现</h4><p>1.定义Mapper接口.在项目的目录结构下首先创建一个mapper包,在这个包下再根据不同的功能模块来创建mapper接口.注册功能需要在mapper包下创建UserMapper接口然后定义上述两个SQL语句的抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 插入用户的数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户的数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 受影响的行数(增删改都将受影响的行数作为返回值,可以根据返回值来判断是否执行成功)</span><br><span class="hljs-comment">     */</span><br>    Integer <span class="hljs-title function_">insert</span><span class="hljs-params">(User user)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据用户名来查询用户的数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果找到对应的用户则返回这个用户的数据,如果没有找到则返回null</span><br><span class="hljs-comment">     */</span><br>    User <span class="hljs-title function_">findByUsername</span><span class="hljs-params">(String username)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.ssm框架开发项目的时候需要在mapper接口上加@Mapper用于自动生成相应的接口实现类,在springboot也可以这样,但是后续会有很多mapper接口,每个接口分别加@Mapper太麻烦了,所以在启动类类里面指定当前项目的mapper接口在哪,然后项目启动的时候会自动加载所有的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.cy.mapper&quot;)</span><br></code></pre></td></tr></table></figure><p>3.3编写映射</p><p>1.定义xml映射文件,与对应的接口进行关联.所有的映射文件都属于资源文件,需要放在resources目录下,为了管理方便我们在resources目录下创建一个mapper文件夹,然后在这个文件夹里存放mapper的映射文件</p><p>2.创建接口的映射文件,需要和接口的名称保持一致.如UserMapper.xml</p><p>UserMapper.xml的配置在Mybatis官网</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--namespace用于指定当前的映射文件和哪个接口进行映射,需要指定接口的文件路径,路径需要是包的完整路径结构--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.cy.store.mapper.UserMapper&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.将配置接口的方法对应到SQL语句上</p><ul><li>insert into () values (),因为values后面插入的值是动态值,mybatis规定需要用占位符来占位,并给占位符起一个变量的名字,且变量的名字需要在占位符#{}内部</li><li>创建t_user表时uid INT AUTO_INCREMENT COMMENT ‘用户id’,中的AUTO_INCREMENT表示主键uid自增,所以需要useGeneratedKeys和keyProperty</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在sql语句的最上面借助ResultMap标签来自定义映射规则</span><br><span class="hljs-comment">    id属性:表示给这个映射规则分配一个唯一的id值,对应的就是resultMap=&quot;id属性值&quot;</span><br><span class="hljs-comment">    type属性:取值是一个类,表示数据库中的查询结果与java中哪个实体类进行结果集的映射</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserEntityMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.cy.store.entity.User&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--将表的字段和类的属性名不一致的进行匹配指定,名称一致的也可以指定,但没必要</span><br><span class="hljs-comment">        但是,在定义映射规则时无论主键名称是否一致都不能省</span><br><span class="hljs-comment">        column属性:表示表中的字段名称</span><br><span class="hljs-comment">        property属性:表示类中的属性名称</span><br><span class="hljs-comment">        --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;uid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;is_delete&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;isDelete&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;created_user&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;createdUser&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;created_time&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;createdTime&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;modified_user&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;modifiedUser&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;modified_time&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;modifiedTime&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--id属性:表示映射的接口中方法的名称,直接标签的内容部来编写SQL语句--&gt;</span><br><span class="hljs-comment">&lt;!--useGeneratedKeys=&quot;true&quot;表示开启某个字段的值递增(大部分都是主键递增)</span><br><span class="hljs-comment">    keyProperty=&quot;uid&quot;表示将表中哪个字段进行递增</span><br><span class="hljs-comment">    --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;uid&quot;</span>&gt;</span><br>    insert into t_user(<br>        username,`password`,salt,phone,email,gender,avatar,is_delete,<br>        created_user,created_time,modified_user,modified_time<br>    ) values (<br>    #&#123;username&#125;,#&#123;password&#125;,#&#123;salt&#125;,#&#123;phone&#125;,#&#123;email&#125;,#&#123;gender&#125;,#&#123;avatar&#125;,#&#123;isDelete&#125;,#&#123;createdUser&#125;,#&#123;createdTime&#125;,#&#123;modifiedUser&#125;,#&#123;modifiedTime&#125;<br>    )<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!--select语句在执行的时候查询的结果无非两种:一个对象或多个对象</span><br><span class="hljs-comment">    resultType:表示查询的结果集类型,用来指定对应映射类的类型,且包含完整的包结构,但此处不能是resultType=&quot;com.cy.store.entity.User&quot;,因为这种写法要求表的字段的名字和类的属性名一模一样</span><br><span class="hljs-comment">    resultMap:表示当表的字段和类的对象属性名不一致时,来自定义查询结果集的映射规则</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findByUsername&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserEntityMap&quot;</span>&gt;</span><br>    select * from t_user where username=#&#123;username&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>sql语句匹配规则:如果在insert标签里面写了insert语句,首先将insert语句和某一个方法进行绑定，用到了id=“”，但是和哪里的方法进行绑定呢，就要用到namespace=“”，这两步映射就把唯一的SQL语句和唯一的方法进行了关联，实际上就是jdbc里面dao接口的的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer insert（User user） &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">SQL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into () values ()&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用到映射的好处:使SQL语句和java代码分离,解耦了,方便后期代码的维护</p><p>4.将mapper文件的位置注册到properties对应的配置文件中.</p><p>在application.properties文件中增添:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mapper/*.xml</span><br></code></pre></td></tr></table></figure><p>3.4单元测试</p><p>1.每个独立的层编写完毕后需要编写单元测试方法来测试当前的功能:在test包结构下创建一个mapper包,在这个包下再创建持久层的功能测试,单元测试方法是独立运行,不用启动整个项目,提高了代码的测试效率</p><p>2.因为测试方法要用到mapper层的接口来访问刚刚写的两个方法,所以要在类里面声明UserMapper对象:即private UserMapper userMapper;且需要加上@Autowired完成值的初始化,但此时会发现提示”Could not autowire.No beans of’UserMapper’type found”,报错原因是idea有自动检测的功能,在java中接口是不能够直接创建bean的,所以idea认为这个语法不合理,但本质上在项目启动时mybatis自动创建了接口的动态代理实现类,所以从项目的运行角度讲这不能算是错.解决办法:</p><ul><li>在Settings里面搜索inspections,依次找到Spring-&gt;Spring Core-&gt;Code-&gt;Autowiring for Bean Class然后将Severity的Error改为Warning</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@SpringBootTest表示当前的类是一个测试类,不会随同项目一块打包</span><br><span class="hljs-meta">@SpringBootTest</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1.<span class="hljs-doctag">@RunWith</span>表示启动这个单元测试类,否则这个单元测试类是不能运行的,需要传递</span><br><span class="hljs-comment"> * 一个参数,该参数必须是SpringRunner.class即SpringRunner的实例类型</span><br><span class="hljs-comment"> * 2.敲完<span class="hljs-doctag">@RunWith</span>(SpringRunner.class)后鼠标分别放在SpringRunner和<span class="hljs-doctag">@RunWith</span>上按alt+enter分别导入包</span><br><span class="hljs-comment"> * 3.单元测试类中出现的方法必须是单元测试方法</span><br><span class="hljs-comment"> * 4.单元测试方法的特点:必须被<span class="hljs-doctag">@Test</span>注解修饰;返回值类型必须是void;方法的参数列表不指定任何类型;方法的访问修饰符必须是public</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMapperTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setUsername(<span class="hljs-string">&quot;张三&quot;</span>);<br>        user.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> userMapper.insert(user);<br>        System.out.println(rows);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findByUsername</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.findByUsername(<span class="hljs-string">&quot;张三&quot;</span>);<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.注册-业务层</p><p>业务层的核心功能:</p><ul><li>接受前端从控制器流转过来的数据</li><li>结合真实的注册业务来完成功能业务逻辑的调转和流程</li></ul><p>所以这里要考虑到真实的业务场景,如果只考虑业务场景的话不完整,因为在整个业务执行的过程中会产生很多问题,从java角度来讲这些都是属于异常,所以在业务开发的时候就要规划相关的异常,以便把项目的错误控制在一定范围内</p><p>service下的目录结构(建议这样):</p><ul><li>service包下创建ex包用来写异常类</li><li>service包下创建impl包用来写接口的实现类</li><li>接口直接写在service包下,不再需要接口包</li></ul><p>4.1规划异常</p><p>1.为什么会有异常:</p><p>比如,用户在进行注册时可能会产生用户名被占用的错误,这时需要抛出一个异常</p><p>2.怎么处理异常:</p><ul><li>异常不能用RuntimeException,太笼统了,开发者没办法第一时间定位到具体的错误类型上,我们可以定义具体的异常类型来继承这个异常.</li><li>正常的开发中异常又要分等级,可能是在业务层产生异常,可能是在控制层产生异常,所以可以创建一个业务层异常的基类,起名ServiceException异常,并使其继承RuntimeException异常</li><li>后期开发业务层时具体的异常可以再继承业务层的异常ServiceException</li></ul><p>3.处理异常的具体步骤:</p><p>步骤一:在ex包下创建ServiceException类作为业务层异常的基类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 因为整个业务的异常只有一种情况下才会产生:只有运行时才会产生,不运行不会产生</span><br><span class="hljs-comment"> * 所以要求业务层的异常都要继承运行时异常RuntimeException并且重写父类的所有构造方法以便后期能抛出自已定义的异常</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span>&#123;<br>    <span class="hljs-comment">//什么也不返回</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServiceException</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//返回异常信息(常用)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServiceException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br><br>    <span class="hljs-comment">//返回异常信息和异常对象(常用)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServiceException</span><span class="hljs-params">(String message, Throwable cause)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message, cause);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServiceException</span><span class="hljs-params">(Throwable cause)</span> &#123;<br>        <span class="hljs-built_in">super</span>(cause);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">ServiceException</span><span class="hljs-params">(String message, Throwable cause, <span class="hljs-type">boolean</span> enableSuppression, <span class="hljs-type">boolean</span> writableStackTrace)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message, cause, enableSuppression, writableStackTrace);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>步骤二:后期再根据业务层不同的功能来详细定义具体的异常类型,并统一的继承ServiceException异常基类:</p><ul><li>用户在进行注册时可能会产生用户名被占用的错误,这时需要抛出一个UsernameDuplicatedException异常</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsernameDuplicatedException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceException</span></span>&#123;<br>    <span class="hljs-comment">/**重写ServiceException的所有构造方法  ctrl + O 需要重写五个方法*/</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>正在执行数据插入操作的时候,服务器宕机或数据库宕机.这种情况是处于正在执行插入的过程中所产生的异常,起名InsertException异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数据插入过程中产生异常</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InsertException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceException</span>&#123;<br>    <span class="hljs-comment">/**重写ServiceException的所有构造方法*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2设计接口和抽象方法"><a href="#4-2设计接口和抽象方法" class="headerlink" title="4.2设计接口和抽象方法"></a>4.2设计接口和抽象方法</h4><p>1.在service包下创建IUserService接口(接口命名的默认规则:I+业务名字+层的名字)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**用户模块业务层接口*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserService</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户注册方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户的数据对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reg</span><span class="hljs-params">(User user)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.创建一个实现UserServiceImpl类,需要实现IUserService接口,并且实现抽象的方法</p><p>因为要将这个实现类交给spring管理,所以需要在类上加@Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span> &#123;<br><br>    <span class="hljs-comment">//reg方法核心就是调用mapper层的方法,所以要声明UserMapper对象并加@Autowired注解</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reg</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-comment">//通过user参数来获取传递过来的username</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> user.getUsername();<br>        <span class="hljs-comment">//调用mapper的findByUsername(username)判断用户是否被注册过了</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.findByUsername(username);<br>        <span class="hljs-comment">//判断结果集是否为null,不为null的话则需抛出用户名被占用的异常</span><br>        <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameDuplicatedException</span>(<span class="hljs-string">&quot;用户名被占用&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 密码加密处理作用:</span><br><span class="hljs-comment">         * 1.后端不再能直接看到用户的密码2.忽略了密码原来的强度,提升了数据安全性</span><br><span class="hljs-comment">         * 密码加密处理的实现:</span><br><span class="hljs-comment">         * 串+password+串-&gt;交给md5算法连续加密三次</span><br><span class="hljs-comment">         * 串就是数据库字段中的盐值,是一个随机字符串</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">oldpassword</span> <span class="hljs-operator">=</span> user.getPassword();<br>        <span class="hljs-comment">//1.随机生成一个盐值(大写的随机字符串)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">salt</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString().toUpperCase();<br>        <span class="hljs-comment">//2.将密码和盐值作为一个整体进行加密处理</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">md5Password</span> <span class="hljs-operator">=</span> getMD5Password(oldpassword, salt);<br>        <span class="hljs-comment">//3.将盐值保存到数据库</span><br>        user.setSalt(salt);<br>        <span class="hljs-comment">//4.将加密之后的密码重新补全设置到user对象当中</span><br>        user.setPassword(md5Password);<br><br>        <span class="hljs-comment">//补全数据:is_delete设置为0</span><br>        user.setIsDelete(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//补全数据:四个日志字段信息</span><br>        user.setCreatedUser(user.getUsername());<br>        user.setModifiedUser(user.getUsername());<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<span class="hljs-comment">//java.util.Date</span><br>        user.setCreatedTime(date);<br>        user.setModifiedTime(date);<br><br><br>        <span class="hljs-comment">//执行注册业务功能的实现</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> userMapper.insert(user);<br>        <span class="hljs-keyword">if</span> (rows != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InsertException</span>(<span class="hljs-string">&quot;在用户注册过程中产生了未知的异常&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>md5加密算法以后可能还要多次用到,为了方便在UserServiceImpl类里面单独写一个getMD5Password方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">getMD5Password</span><span class="hljs-params">(String password,String salt)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        password = DigestUtils.md5DigestAsHex((salt + password + salt).getBytes()).toUpperCase();<br>    &#125;<br>    <span class="hljs-keyword">return</span> password;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.3单元测试</p><p>在单元测试包下创建一个UserServiceTests类,在这个类中添加单元测试的功能(技巧:可以先在test.com.cy.store下创建service包,然后点击UserMapperTests并ctrl+c,然后点击service包ctrl+v会弹出修改类名,将UserMapperTests改为UserServiceTests即可,然后修改部分代码至如下这样)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IUserService userService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reg</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 进行插入时可能会出错抛出异常,这时需要捕获异常:</span><br><span class="hljs-comment">         * 1.选中    User user = new User();</span><br><span class="hljs-comment">         *           user.setUsername(&quot;张7&quot;);</span><br><span class="hljs-comment">         *           user.setPassword(&quot;123456&quot;);</span><br><span class="hljs-comment">         *           userService.reg(user);</span><br><span class="hljs-comment">         *           System.out.println(&quot;OK&quot;);</span><br><span class="hljs-comment">         * 2.点击导航栏的Code,然后依次点击SurroundWith-&gt;try/catch就可以捕获异常了</span><br><span class="hljs-comment">         * 3.Exception e没有问题,但这里我们知道是Service层的异常,所以可以改为ServiceException e</span><br><span class="hljs-comment">         * 4.System.out.println(e.getClass().getSimpleName());获取异常对象再获取类的名称然后输出</span><br><span class="hljs-comment">         * 5.System.out.println(e.getMessage());输出异常信息(是自己在ServiceException的子类类具体设置的信息)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>            user.setUsername(<span class="hljs-string">&quot;张7&quot;</span>);<br>            user.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>            userService.reg(user);<br>            System.out.println(<span class="hljs-string">&quot;OK&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ServiceException e) &#123;<br>            System.out.println(e.getClass().getSimpleName());<br>            System.out.println(e.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-注册-控制层"><a href="#5-注册-控制层" class="headerlink" title="5.注册-控制层"></a>5.注册-控制层</h3><h4 id="5-1创建响应"><a href="#5-1创建响应" class="headerlink" title="5.1创建响应"></a>5.1创建响应</h4><p>状态码,状态描述信息,数据是所有控制层对应的方法都涉及到的操作,所以把这部分功能封装到一个类JsonResult中,将这个类作为方法的返回值返回给前端浏览器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//因为所有的响应的结果都采用Json格式的数据进行响应,所以需要实现Serializable接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonResult</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">//状态码</span><br>    <span class="hljs-keyword">private</span> Integer state;<br>    <span class="hljs-comment">//描述信息</span><br>    <span class="hljs-keyword">private</span> String message;<br>    <span class="hljs-comment">//数据类型不确定,用E表示任何的数据类型,一个类里如果声明的有泛型的数据类型,类也要声明为泛型</span><br>    <span class="hljs-keyword">private</span> E data;<br><br>    <span class="hljs-comment">//无参构造</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JsonResult</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">//将状态码传给构造方法初始化对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JsonResult</span><span class="hljs-params">(Integer state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br><br><br>    <span class="hljs-comment">//将状态码和数据传给构造方法初始化对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JsonResult</span><span class="hljs-params">(Integer state, E data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = state;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-comment">//如果有异常,直接将异常传递给构造方法初始化对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JsonResult</span><span class="hljs-params">(Throwable e)</span> &#123;<br>        <span class="hljs-built_in">this</span>.message=e.getMessage();<br>    &#125;<br>    <span class="hljs-comment">/**以及属性的get和set方法*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>5.2设计请求</p><p>接下来该向后端服务器发送请求以把用户数据插入到数据库,设计发送请求模块的第一步就是设计相关的请求</p><p>依据当前的业务功能模块进行请求的设计:</p><ul><li>请求路径:/users/reg</li><li>请求参数:User user</li><li>请求类型:POST</li><li>响应结果:JsonResult<void></li></ul><p>5.3处理请求</p><p>创建一个控制层对应的UserController类,依赖于业务层的接口.编写完成后启动主服务验证一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RestController</span> <span class="hljs-comment">//其作用等同于@Controller+@ResponseBody</span><br><span class="hljs-comment">//@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;users&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IUserService userService;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;reg&quot;)</span><br>    <span class="hljs-comment">//@ResponseBody //表示此方法的响应结果以json格式进行数据的响应给到前端</span><br>    <span class="hljs-keyword">public</span> JsonResult&lt;Void&gt; <span class="hljs-title function_">reg</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-comment">//创建响应结果对象即JsonResult对象</span><br>        JsonResult&lt;Void&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonResult</span>&lt;&gt;();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//调用userService的reg方法时可能出现异常,所以需要捕获异常</span><br>            userService.reg(user);<br>            result.setState(<span class="hljs-number">200</span>);<br>            result.setMessage(<span class="hljs-string">&quot;用户注册成功&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (UsernameDuplicatedException e) &#123;<br>            result.setState(<span class="hljs-number">4000</span>);<br>            result.setMessage(<span class="hljs-string">&quot;用户名被占用&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InsertException e) &#123;<br>            result.setState(<span class="hljs-number">5000</span>);<br>            result.setMessage(<span class="hljs-string">&quot;注册时产生未知的异常&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.4控制层优化设计</p><p>凡是业务层抛出的异常我们都在控制层进行了捕获,如果其他的业务模块也抛用户名被占用或者插入时异常,那么抛出异常的代码就要重复编写</p><p>优化方法:在控制层抽离出一个BaseController父类,在这个父类中统一处理关于异常的相关操作,优化如下:</p><p>1.在controller包下创建UserController类作为控制层下类的基类,用来做统一的异常捕获:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseController</span> &#123;<br><br>    <span class="hljs-comment">//操作成功的状态码</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OK</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1.<span class="hljs-doctag">@ExceptionHandler</span>表示该方法用于处理捕获抛出的异常</span><br><span class="hljs-comment">     * 2.什么样的异常才会被这个方法处理呢?所以需要ServiceException.class,这样的话只要是抛出ServiceException异常就会被拦截到handleException方法,此时handleException方法就是请求处理方法,返回值就是需要传递给前端的数据</span><br><span class="hljs-comment">     * 3.被ExceptionHandler修饰后如果项目发生异常,那么异常对象就会被自动传递给此方法的参数列表上,所以形参就需要写Throwable e用来接收异常对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(ServiceException.class)</span><br>    <span class="hljs-keyword">public</span> JsonResult&lt;Void&gt; <span class="hljs-title function_">handleException</span><span class="hljs-params">(Throwable e)</span> &#123;<br>        JsonResult&lt;Void&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonResult</span>&lt;&gt;(e);<br>        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> UsernameDuplicatedException) &#123;<br>            result.setState(<span class="hljs-number">4000</span>);<br>            result.setMessage(<span class="hljs-string">&quot;用户名已经被占用&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> InsertException) &#123;<br>            result.setState(<span class="hljs-number">5000</span>);<br>            result.setMessage(<span class="hljs-string">&quot;插入数据时产生未知的异常&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.让UserController继承BaseController并重构UserController下的reg方法使该方法只需要关注请求处理而不再需要关注异常捕获:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> JsonResult&lt;<span class="hljs-type">Void</span>&gt; reg(<span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span>) &#123;<br>    userService.reg(<span class="hljs-keyword">user</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> JsonResult&lt;&gt;(OK);<br>&#125;<br></code></pre></td></tr></table></figure><p>6.注册-前端页面<br>6.1熟悉ajax</p><p>1.什么是ajax函数?</p><p>这是jQuery封装的一个函数,称为$.ajax()函数,通过对象调用ajax()函数用来异步加载相关的请求.依靠的是JavaScript提供的一个对象:XHR(全称XmlHttpResponse)</p><p>2.ajax()函数的语法结构:</p><ul><li>使用ajax()时需要传递一个方法体作为方法的参数来使用(一对大括号就是一个方法体)</li><li>ajax接受多个参数时,参数与参数之间使用”,”分割</li><li>每一组参数之间使用”:”进行分割</li><li>参数的组成部分一个是参数的名称(不能随便定义),另一个是参数的值(必须用字符串来表示)</li><li>参数的声明顺序没有要求</li></ul><p>演示一下语法结构:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">ajax</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">data</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">dataType</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <br>    &#125;,<br>    <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>功能描述</th></tr></thead><tbody><tr><td>url</td><td>表示请求的地址(url地址),例如:url:“localhost:8080/users/reg”(1.不能包含参数列表部分的内容2.如果提交的请求是项目内部的一个url,那么端口号前面的都可以省略掉,即url:“/users/reg”)</td></tr><tr><td>type</td><td>请求类型(GET和POST请求的类型).例如:type:“POST”(get和post不区分大小写)</td></tr><tr><td>data</td><td>向指定的请求url地址提交的数据.例如:data:“username=tom&amp;pwd=123”</td></tr><tr><td>dataType</td><td>提交的数据的类型.数据的类型一般指定为json类型.例如:dataType:“json”(json不区分大小写)</td></tr><tr><td>success</td><td>当服务器正常响应客户端时,会自动调用success参数的方法,并且将服务器返回的数据以参数的形式传递给这个方法的参数上</td></tr><tr><td>error</td><td>当服务器未正常响应客户端时,会自动调用error参数的方法,并且将服务器返回的数据以参数的形式传递给这个方法的参数上</td></tr></tbody></table><p>6.2前端js编写</p><p>js代码可以独立声明在一个js文件里或者声明在一个script标签中.现在我们在register.html中编写js代码,js代码可以放在head标签中,也可以放在body标签中,可以放在任意一个位置,只要被script标签包裹就行了,这里我们放在整个body结束之前:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">//1.监听注册按钮是否被点击,如果被点击可以执行一个方法(这里不能像ajax函数那样删去function()只留下&#123;&#125;,这是官方规定的!)</span><br>    $(<span class="hljs-string">&quot;#btn-reg&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><br>        <span class="hljs-comment">//let username = $(&quot;#username&quot;).val();</span><br>        <span class="hljs-comment">//let pwd = $(&quot;#password&quot;).val();</span><br>        <span class="hljs-comment">//上面这两行是动态获取表单中控件的数据,但是如果这样获取的话ajax函数中</span><br>        <span class="hljs-comment">//就是data: &quot;username=&quot;+username + &quot;&amp;password=&quot;+pwd,但太麻烦了,如</span><br>        <span class="hljs-comment">// 果这个表单提交的是用户的兴趣爱好,那数据就很多了,一个表单20个数据都很正</span><br>        <span class="hljs-comment">// 常,如果此时还用这种方式就太麻烦了,所以不建议用这种方式</span><br><br>        <span class="hljs-comment">//2.发送ajax()的异步请求来完成用户的注册功能</span><br>        $.<span class="hljs-title function_">ajax</span>(&#123;<br>            <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/users/reg&quot;</span>,<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;POST&quot;</span>,<br><br>            <span class="hljs-comment">//serialize这个API会自动检测该表单有什么控件,每个控件检测后还会获取每个控</span><br>            <span class="hljs-comment">// 件的值,拿到这个值后并自动拼接成形如username=Tom&amp;password=123的结构</span><br>            <span class="hljs-attr">data</span>: $(<span class="hljs-string">&quot;#form-reg&quot;</span>).<span class="hljs-title function_">serialize</span>(),<br><br>            <span class="hljs-attr">dataType</span>: <span class="hljs-string">&quot;JSON&quot;</span>,<br>            <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">json</span>) &#123; <span class="hljs-comment">//1.js是弱数据类型,这个地方不用声明json的数据类型</span><br>                <span class="hljs-comment">//2.如果服务器成功响应就会将返回的数据传给形参,比如&#123;state: 4000,message: &quot;用户名</span><br>                <span class="hljs-comment">// 已经被占用&quot;,data: null&#125;</span><br>                <span class="hljs-keyword">if</span> (json.<span class="hljs-property">state</span> == <span class="hljs-number">200</span>) &#123;<br>                    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;注册成功&quot;</span>)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;注册失败&quot;</span>)<br>                &#125;<br>            &#125;,<br>            <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) &#123; <span class="hljs-comment">//如果问题不在可控范围内,服务器就不会返回自己定</span><br>                <span class="hljs-comment">//义的json字符串:&#123;state: 4000,message: &quot;用户名已经被占用&quot;,data: null&#125;</span><br>                <span class="hljs-comment">//而是返回一个XHR类型的对象,该对象也有一个状态码名字是status</span><br>                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;注册时产生未知的错误!&quot;</span>+xhr.<span class="hljs-property">status</span>);<br>            &#125;<br>        &#125;);<br>    &#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>此时可能会出现点击注册提交表单时没有任何响应,原因是idea对于JS代码的兼容性较差,编写了js代码但是有的时候不能正常去加载,解决办法有四种,同前面的:项目环境搭建-&gt;项目测试-&gt;测试静态资源能否正常加载</p><p>包括以后如果修改了前端页面,测试时没有报错也没有按照预想的响应,就考虑是编写的js代码还没有被加载,尝试用这四种方法解决.</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>电脑商城</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSM</tag>
      
      <tag>项目练习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis的Java客户端</title>
    <link href="/2023/04/23/Redis%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <url>/2023/04/23/Redis%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="3-Redis的Java客户端"><a href="#3-Redis的Java客户端" class="headerlink" title="3.Redis的Java客户端"></a>3.Redis的Java客户端</h1><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p><p><img src="p1.png" alt="Redis的Java客户端"></p><p>其中Java客户端也包含很多：</p><p><img src="p2.png" alt="Redis的Java客户端"></p><p>标记为*的就是推荐使用的java客户端，包括：</p><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><p><img src="p3.png" alt="Redis的Java客户端"></p><h2 id="3-1-Jedis客户端"><a href="#3-1-Jedis客户端" class="headerlink" title="3.1.Jedis客户端"></a>3.1.Jedis客户端</h2><p>Jedis的官网地址： <a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p><h3 id="3-1-1-快速入门"><a href="#3-1-1-快速入门" class="headerlink" title="3.1.1.快速入门"></a>3.1.1.快速入门</h3><p>我们先来个快速入门：</p><p>1）引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jedis--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--单元测试--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）建立连接</p><p>新建一个单元测试类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Jedis jedis;<br><br><span class="hljs-meta">@BeforeEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.建立连接</span><br>    <span class="hljs-comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span><br>    jedis = JedisConnectionFactory.getJedis();<br>    <span class="hljs-comment">// 2.设置密码</span><br>    jedis.auth(<span class="hljs-string">&quot;123321&quot;</span>);<br>    <span class="hljs-comment">// 3.选择库</span><br>    jedis.select(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>3）测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 存入数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;虎哥&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>    <span class="hljs-comment">// 获取数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 插入hash数据</span><br>    jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>);<br>    jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;21&quot;</span>);<br><br>    <span class="hljs-comment">// 获取</span><br>    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="hljs-string">&quot;user:1&quot;</span>);<br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure><p>4）释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;<br>        jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-1-2-连接池"><a href="#3-1-2-连接池" class="headerlink" title="3.1.2.连接池"></a>3.1.2.连接池</h3><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heima.jedis.util;<br><br><span class="hljs-keyword">import</span> redis.clients.jedis.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisConnectionFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 配置连接池</span><br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        poolConfig.setMaxTotal(<span class="hljs-number">8</span>);<br>        poolConfig.setMaxIdle(<span class="hljs-number">8</span>);<br>        poolConfig.setMinIdle(<span class="hljs-number">0</span>);<br>        poolConfig.setMaxWaitMillis(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码</span><br>        jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(poolConfig, <span class="hljs-string">&quot;192.168.150.101&quot;</span>, <span class="hljs-number">6379</span>, <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;123321&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> jedisPool.getResource();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-SpringDataRedis客户端"><a href="#3-2-SpringDataRedis客户端" class="headerlink" title="3.2.SpringDataRedis客户端"></a>3.2.SpringDataRedis客户端</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="p4.png" alt="Redis的Java客户端"></p><h3 id="3-2-1-快速入门"><a href="#3-2-1-快速入门" class="headerlink" title="3.2.1.快速入门"></a>3.2.1.快速入门</h3><p>SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单。</p><p>首先，新建一个maven项目，然后按照下面步骤执行：</p><h4 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.heima<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redis-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>redis-demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--redis依赖--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--common-pool--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--Jackson依赖--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2）配置Redis"><a href="#2）配置Redis" class="headerlink" title="2）配置Redis"></a>2）配置Redis</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123321</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">100ms</span><br></code></pre></td></tr></table></figure><h4 id="3）注入RedisTemplate"><a href="#3）注入RedisTemplate" class="headerlink" title="3）注入RedisTemplate"></a>3）注入RedisTemplate</h4><p>因为有了SpringBoot的自动装配，我们可以拿来就用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStringTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4）编写测试"><a href="#4）编写测试" class="headerlink" title="4）编写测试"></a>4）编写测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStringTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate edisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 写入一条String数据</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;虎哥&quot;</span>);<br>        <span class="hljs-comment">// 获取string数据</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-2-自定义序列化"><a href="#3-2-2-自定义序列化" class="headerlink" title="3.2.2.自定义序列化"></a>3.2.2.自定义序列化</h3><p>RedisTemplate可以接收任意Object作为值写入Redis：</p><p><img src="p5.png" alt="Redis的Java客户端"></p><p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p><p><img src="p6.png" alt="Redis的Java客户端"></p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span>&#123;<br>        <span class="hljs-comment">// 创建RedisTemplate对象</span><br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        <span class="hljs-comment">// 设置连接工厂</span><br>        template.setConnectionFactory(connectionFactory);<br>        <span class="hljs-comment">// 创建JSON序列化工具</span><br>        <span class="hljs-type">GenericJackson2JsonRedisSerializer</span> <span class="hljs-variable">jsonRedisSerializer</span> <span class="hljs-operator">=</span> <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericJackson2JsonRedisSerializer</span>();<br>        <span class="hljs-comment">// 设置Key的序列化</span><br>        template.setKeySerializer(RedisSerializer.string());<br>        template.setHashKeySerializer(RedisSerializer.string());<br>        <span class="hljs-comment">// 设置Value的序列化</span><br>        template.setValueSerializer(jsonRedisSerializer);<br>        template.setHashValueSerializer(jsonRedisSerializer);<br>        <span class="hljs-comment">// 返回</span><br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p><p><img src="p7.png" alt="Redis的Java客户端"></p><p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p><h3 id="3-2-3-StringRedisTemplate"><a href="#3-2-3-StringRedisTemplate" class="headerlink" title="3.2.3.StringRedisTemplate"></a>3.2.3.StringRedisTemplate</h3><p>为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</p><p><img src="p8.png" alt="Redis的Java客户端"></p><p>因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了。</p><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p><p><img src="p9.png" alt="Redis的Java客户端"></p><p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><span class="hljs-comment">// JSON序列化工具，也可以采用fastjson，根据个人习惯</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testSaveUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;<br>    <span class="hljs-comment">// 创建对象</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;虎哥&quot;</span>, <span class="hljs-number">21</span>);<br>    <span class="hljs-comment">// 手动序列化</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(user);<br>    <span class="hljs-comment">// 写入数据</span><br>    stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;user:200&quot;</span>, json);<br><br>    <span class="hljs-comment">// 获取数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">jsonUser</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;user:200&quot;</span>);<br>    <span class="hljs-comment">// 手动反序列化</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mapper.readValue(jsonUser, User.class);<br>    System.out.println(<span class="hljs-string">&quot;user1 = &quot;</span> + user1);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nosql</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis常用命令</title>
    <link href="/2023/04/23/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/04/23/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h1><p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：</p><p><img src="p1.png" alt="Redis常用命令"></p><p>Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在<a href="https://redis.io/commands">官网</a> <a href="https://redis.io/commands"> </a>可以查看到不同的命令：</p><p><img src="p2.png" alt="Redis常用命令"></p><p>不同类型的命令称为一个group，我们也可以通过help命令来查看各种不同group的命令：</p><p><img src="p3.png" alt="Redis常用命令"></p><p>接下来，我们就学习常见value值的五种基本数据类型的相关命令。</p><h2 id="2-1-Redis通用命令"><a href="#2-1-Redis通用命令" class="headerlink" title="2.1.Redis通用命令"></a>2.1.Redis通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li>KEYS：查看符合模板的所有key，不建议在生产环境设备上使用，会阻塞所有请求。</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li><li>TTL：查看一个KEY的剩余有效期</li><li>补充      看老师演示：select   库的索引号（0 –15）表示切换到对应索引的库。</li></ul><p>通过help [command] 可以查看一个命令的具体用法，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看keys命令的帮助信息：</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">help</span> keys<br><br>KEYS pattern<br>summary: Find all keys matching the given pattern<br>since: 1.0.0<br>group: generic<br></code></pre></td></tr></table></figure><h2 id="2-2-String类型"><a href="#2-2-String类型" class="headerlink" title="2.2.String类型"></a>2.2.String类型</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以做自增、自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p><p><img src="p4.png" alt="Redis常用命令"></p><h3 id="2-2-1-String的常见命令"><a href="#2-2-1-String的常见命令" class="headerlink" title="2.2.1.String的常见命令"></a>2.2.1.String的常见命令</h3><p>String的常见命令有：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><h3 id="2-2-2-Key结构"><a href="#2-2-2-Key结构" class="headerlink" title="2.2.2.Key结构"></a>2.2.2.Key结构</h3><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p><p>例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">项目名:业务名:类型:<span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样以来，我们就可以把不同类型的数据区分开了。从而避免了key的冲突问题。</p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>heima:user:1</td><td>{“id”:1,  “name”: “Jack”, “age”: 21}</td></tr><tr><td>heima:product:1</td><td>{“id”:1,  “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><p>并且，在Redis的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰：</p><p><img src="p5.png" alt="Redis常用命令"></p><h2 id="2-3-Hash类型"><a href="#2-3-Hash类型" class="headerlink" title="2.3.Hash类型"></a>2.3.Hash类型</h2><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><img src="p6.png" alt="Redis常用命令"></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="p7.png" alt="Redis常用命令"></p><p>Hash的常见命令有：</p><ul><li><p>HSET key field value：添加或者修改hash类型key的field的值</p></li><li><p>HGET key field：获取一个hash类型key的field的值</p></li><li><p>HMSET：批量添加多个hash类型key的field的值</p></li><li><p>HMGET：批量获取多个hash类型key的field的值</p></li><li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p></li><li><p>HKEYS：获取一个hash类型的key中的所有的field</p></li><li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p></li><li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p></li></ul><h2 id="2-4-List类型"><a href="#2-4-List类型" class="headerlink" title="2.4.List类型"></a>2.4.List类型</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p>List的常见命令有：</p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素（索引从0开始）</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><p><img src="p8.png" alt="Redis常用命令"></p><h2 id="2-5-Set类型"><a href="#2-5-Set类型" class="headerlink" title="2.5.Set类型"></a>2.5.Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li><p>无序</p></li><li><p>元素不可重复</p></li><li><p>查找快</p></li><li><p>支持交集、并集、差集等功能</p></li></ul><p>Set的常见命令有：</p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li><li>SDIFF Key1 Key2…:求Key1与Key2的差集</li><li>SUNION key1 key2…：求key1和key2的并集</li></ul><p>例如两个集合：s1和s2:</p><p><img src="p9.png" alt="Redis常用命令"></p><p>求交集：SINTER s1 s2</p><p>求s1与s2的不同：SDIFF s1 s2</p><p><img src="p10.png" alt="Redis常用命令"></p><p>练习：</p><ol><li>将下列数据用Redis的Set集合来存储：</li></ol><ul><li>张三的好友有：李四、王五、赵六</li><li>李四的好友有：王五、麻子、二狗</li></ul><ol start="2"><li>利用Set的命令实现下列功能：</li></ol><ul><li>计算张三的好友有几人</li><li>计算张三和李四有哪些共同好友</li><li>查询哪些人是张三的好友却不是李四的好友</li><li>查询张三和李四的好友总共有哪些人</li><li>判断李四是否是张三的好友</li><li>判断张三是否是李四的好友</li><li>将李四从张三的好友列表中移除</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sh">- 张三的好友有：李四、王五、赵六<br>SADD zs lisi wangwu zhaaoliu<br>- 李四的好友有：王五、麻子、二狗<br>SADD <span class="hljs-built_in">ls</span> wangwu mazi ergou<br>- 计算张三的好友有几人<br>SCARD zs<br>- 计算张三和李四有哪些共同好友<br>SINTER　zs　<span class="hljs-built_in">ls</span><br>- 查询哪些人是张三的好友却不是李四的好友<br>SDIFF zs <span class="hljs-built_in">ls</span><br>- 查询张三和李四的好友总共有哪些人<br>SUNION zs <span class="hljs-built_in">ls</span><br>- 判断李四是否是张三的好友<br>SISMEMBER zs lisi<br>- 判断张三是否是李四的好友<br>SISMEMBER <span class="hljs-built_in">ls</span> zhangsan<br>- 将李四从张三的好友列表中移除<br>SREM zs lisi<br></code></pre></td></tr></table></figure><p>涨个小知识：全角和半角</p><p><img src="p11.png" alt="Redis常用命令"></p><h2 id="2-6-SortedSet类型"><a href="#2-6-SortedSet类型" class="headerlink" title="2.6.SortedSet类型"></a>2.6.SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</p></li><li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</p></li></ul><p>练习题：</p><p>将班级的下列学生得分存入Redis的SortedSet中：</p><p>Jack 85, Lucy 89, Rose 82, Tom 95, Jerry 78, Amy 92, Miles 76</p><p>并实现下列功能：</p><ul><li>删除Tom同学</li><li>获取Amy同学的分数</li><li>获取Rose同学的排名</li><li>查询80分以下有几个学生</li><li>给Amy同学加2分</li><li>查出成绩前3名的同学</li><li>查出成绩80分以下的所有同学</li></ul><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tap">将班级的下列学生得分存入Redis的SortedSet中：<br>ZADD stus<span class="hljs-number"> 85 </span>Jack<span class="hljs-number"> 89 </span>Lucy<span class="hljs-number"> 82 </span>Rose<span class="hljs-number"> 95 </span>Tom<span class="hljs-number"> 78 </span>Jerry<span class="hljs-number"> 92 </span>Amy<span class="hljs-number"> 76 </span>Miles <br>- 删除Tom同学<br>ZREM stus Tom<br>- 获取Amy同学的分数<br>ZDCORE stus Amy<br>- 获取Rose同学的排名<br>ZREVRANK stus Rose<br>- 查询80分以下有几个学生<br>ZCOUNT stus<span class="hljs-number"> 0 </span>80<br>- 给Amy同学加2分<br>ZINCRBY stus<span class="hljs-number"> 2 </span>Amy<br>- 查出成绩前3名的同学<br>ZREVRANGE<span class="hljs-number"> 0 </span>2<br>- 查出成绩80分以下的所有同学<br>ZRANGEBYSCORE stus<span class="hljs-number"> 0 </span>80<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nosql</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识Redis</title>
    <link href="/2023/04/23/%E5%88%9D%E8%AF%86Redis/"/>
    <url>/2023/04/23/%E5%88%9D%E8%AF%86Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="1-初识Redis"><a href="#1-初识Redis" class="headerlink" title="1.初识Redis"></a>1.初识Redis</h1><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p><ul><li><p>键值型</p></li><li><p>NoSql</p></li></ul><p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至json：</p><p><img src="p1.png" alt="初识Redis"></p><p>而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。</p><h2 id="1-1-认识NoSQL"><a href="#1-1-认识NoSQL" class="headerlink" title="1.1.认识NoSQL"></a>1.1.认识NoSQL</h2><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<strong>非关系型数据库</strong>。</p><h3 id="1-1-1-结构化与非结构化"><a href="#1-1-1-结构化与非结构化" class="headerlink" title="1.1.1.结构化与非结构化"></a>1.1.1.结构化与非结构化</h3><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束：</p><p><img src="p2.png" alt="初识Redis"></p><p>而NoSql则对数据库格式没有严格约束，往往形式松散，自由。</p><p>可以是键值型：</p><p><img src="p3.png" alt="初识Redis"></p><p>也可以是文档型：</p><p><img src="p4.png" alt="初识Redis"></p><p>甚至可以是图格式：</p><p><img src="p5.png" alt="初识Redis"></p><h3 id="1-1-2-关联和非关联"><a href="#1-1-2-关联和非关联" class="headerlink" title="1.1.2.关联和非关联"></a>1.1.2.关联和非关联</h3><p>传统数据库的表与表之间往往存在关联，例如外键：</p><p><img src="p6.png" alt="初识Redis"></p><p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  id<span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  name<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;张三&quot;</span><span class="hljs-punctuation">,</span><br>  orders<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>       id<span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>       item<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br> id<span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span> title<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;荣耀6&quot;</span><span class="hljs-punctuation">,</span> price<span class="hljs-punctuation">:</span> <span class="hljs-number">4999</span><br>       <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>       id<span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>       item<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br> id<span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><span class="hljs-punctuation">,</span> title<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小米11&quot;</span><span class="hljs-punctuation">,</span> price<span class="hljs-punctuation">:</span> <span class="hljs-number">3999</span><br>       <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。</p><h3 id="1-1-3-查询方式"><a href="#1-1-3-查询方式" class="headerlink" title="1.1.3.查询方式"></a>1.1.3.查询方式</h3><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p><p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p><p><img src="p7.png" alt="初识Redis"></p><h3 id="1-1-4-事务"><a href="#1-1-4-事务" class="headerlink" title="1.1.4.事务"></a>1.1.4.事务</h3><p>传统关系型数据库能满足事务ACID的原则。</p><p><img src="p8.png" alt="初识Redis"></p><p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p><h3 id="1-1-5-总结"><a href="#1-1-5-总结" class="headerlink" title="1.1.5.总结"></a>1.1.5.总结</h3><p>除了上述四点以外，在存储方式、扩展性、查询性能上关系型与非关系型也都有着显著差异，总结如下：</p><p><img src="p9.png" alt="初识Redis"></p><ul><li>存储方式<ul><li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li><li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li></ul></li></ul><ul><li>扩展性<ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li><li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li><li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li></ul></li></ul><h2 id="1-2-认识Redis"><a href="#1-2-认识Redis" class="headerlink" title="1.2.认识Redis"></a>1.2.认识Redis</h2><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p><strong>特征</strong>：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><p><strong>作者</strong>：Antirez</p><p>Redis的官方网站地址：<a href="https://redis.io/">Redis</a></p><h2 id="1-3-安装Redis"><a href="#1-3-安装Redis" class="headerlink" title="1.3.安装Redis"></a>1.3.安装Redis</h2><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此我们会基于Linux系统来安装Redis.</p><p>此处选择的Linux版本为CentOS 7.</p><h3 id="1-3-1-依赖库"><a href="#1-3-1-依赖库" class="headerlink" title="1.3.1.依赖库"></a>1.3.1.依赖库</h3><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum install -y gcc tcl<br></code></pre></td></tr></table></figure><h3 id="1-3-2-上传安装包并解压"><a href="#1-3-2-上传安装包并解压" class="headerlink" title="1.3.2.上传安装包并解压"></a>1.3.2.上传安装包并解压</h3><p>然后将Redis安装包上传到虚拟机的任意目录：</p><p><img src="p10.png" alt="初识Redis"></p><p>例如，我放到了/usr/local/src 目录：</p><p><img src="p11.png" alt="初识Redis"></p><p>解压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xzf redis-6.2.6.tar.gz<br></code></pre></td></tr></table></figure><p>解压后：</p><p><img src="p12.png" alt="初识Redis"></p><p>进入redis目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> redis-6.2.6<br></code></pre></td></tr></table></figure><p>运行编译命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>如果没有出错，应该就安装成功了。</p><p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p><p><img src="p13.jpg" alt="初识Redis"></p><p>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><h3 id="1-3-3-启动"><a href="#1-3-3-启动" class="headerlink" title="1.3.3.启动"></a>1.3.3.启动</h3><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h3 id="1-3-4-默认启动"><a href="#1-3-4-默认启动" class="headerlink" title="1.3.4.默认启动"></a>1.3.4.默认启动</h3><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">redis-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>如图：</p><p><img src="p14.png" alt="初识Redis"></p><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h3 id="1-3-5-指定配置启动"><a href="#1-3-5-指定配置启动" class="headerlink" title="1.3.5.指定配置启动"></a>1.3.5.指定配置启动</h3><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p><img src="p15.png" alt="初识Redis"></p><p>我们先将这个配置文件备份一份：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cp</span> redis.<span class="hljs-keyword">conf</span> redis.<span class="hljs-keyword">conf</span>.bck<br></code></pre></td></tr></table></figure><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span><br><span class="hljs-attr">bind</span> <span class="hljs-string">0.0.0.0</span><br><span class="hljs-comment"># 守护进程，修改为yes后即可后台运行</span><br><span class="hljs-attr">daemonize</span> <span class="hljs-string">yes </span><br><span class="hljs-comment"># 密码，设置后访问Redis必须输入密码</span><br><span class="hljs-attr">requirepass</span> <span class="hljs-string">123321</span><br></code></pre></td></tr></table></figure><p>Redis的其它常见配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 监听的端口</span><br><span class="hljs-attr">port</span> <span class="hljs-string">6379</span><br><span class="hljs-comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span><br><span class="hljs-attr">dir</span> <span class="hljs-string">.</span><br><span class="hljs-comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span><br><span class="hljs-attr">databases</span> <span class="hljs-string">1</span><br><span class="hljs-comment"># 设置redis能够使用的最大内存</span><br><span class="hljs-attr">maxmemory</span> <span class="hljs-string">512mb</span><br><span class="hljs-comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span><br><span class="hljs-attr">logfile</span> <span class="hljs-string">&quot;redis.log&quot;</span><br></code></pre></td></tr></table></figure><p>启动Redis：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入redis安装目录 </span><br><span class="hljs-built_in">cd</span> /usr/local/src/redis-6.2.6<br><span class="hljs-comment"># 启动</span><br>redis-server redis.conf<br></code></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span><br><span class="hljs-comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span><br>redis-cli -u 123321 shutdown<br></code></pre></td></tr></table></figure><h3 id="1-3-6-开机自启"><a href="#1-3-6-开机自启" class="headerlink" title="1.3.6.开机自启"></a>1.3.6.开机自启</h3><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vi /etc/systemd/system/redis.service<br></code></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs conf">[Unit]<br>Description=redis-server<br>After=network.target<br><br>[Service]<br>Type=forking<br>ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf<br>PrivateTmp=true<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>然后重载系统服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl daemon-reload<br></code></pre></td></tr></table></figure><p>现在，我们可以用下面这组命令来操作redis了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 启动</span><br>systemctl start redis<br><span class="hljs-comment"># 停止</span><br>systemctl stop redis<br><span class="hljs-comment"># 重启</span><br>systemctl restart redis<br><span class="hljs-comment"># 查看状态</span><br>systemctl status redis<br></code></pre></td></tr></table></figure><p>执行下面的命令，可以让redis开机自启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl <span class="hljs-built_in">enable</span> redis<br></code></pre></td></tr></table></figure><h2 id="1-4-Redis桌面客户端"><a href="#1-4-Redis桌面客户端" class="headerlink" title="1.4.Redis桌面客户端"></a>1.4.Redis桌面客户端</h2><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编程客户端</li></ul><h3 id="1-4-1-Redis命令行客户端"><a href="#1-4-1-Redis命令行客户端" class="headerlink" title="1.4.1.Redis命令行客户端"></a>1.4.1.Redis命令行客户端</h3><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli [options] [commonds]<br></code></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码 </li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p><p><img src="p16.png" alt="初识Redis"></p><h3 id="1-4-2-图形化桌面客户端"><a href="#1-4-2-图形化桌面客户端" class="headerlink" title="1.4.2.图形化桌面客户端"></a>1.4.2.图形化桌面客户端</h3><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a></p><p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p><p>在下面这个仓库可以找到安装包：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p><h3 id="1-4-3-安装"><a href="#1-4-3-安装" class="headerlink" title="1.4.3.安装"></a>1.4.3.安装</h3><p>在课前资料中可以找到Redis的图形化桌面客户端：</p><p><img src="p17.png" alt="初识Redis"></p><p>解压缩后，运行安装程序即可安装：</p><p><img src="p18.png" alt="初识Redis"></p><p>安装完成后，在安装目录下找到rdm.exe文件：</p><p><img src="p19.png" alt="初识Redis"></p><p>双击即可运行：</p><p><img src="p20.png" alt="初识Redis"></p><h3 id="1-4-4-建立连接"><a href="#1-4-4-建立连接" class="headerlink" title="1.4.4.建立连接"></a>1.4.4.建立连接</h3><p>点击左上角的<code>连接到Redis服务器</code>按钮：</p><p><img src="p21.png" alt="初识Redis"></p><p>在弹出的窗口中填写Redis服务信息：</p><p><img src="p22.png" alt="初识Redis"></p><p>点击确定后，在左侧菜单会出现这个链接：</p><p><img src="p23.png" alt="初识Redis"></p><p>点击即可建立连接了。</p><p><img src="p24.png" alt="初识Redis"></p><p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p><p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 选择 0号库</span><br>select 0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nosql</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电脑商城01</title>
    <link href="/2023/04/23/%E7%94%B5%E8%84%91%E5%95%86%E5%9F%8E01/"/>
    <url>/2023/04/23/%E7%94%B5%E8%84%91%E5%95%86%E5%9F%8E01/</url>
    
    <content type="html"><![CDATA[<h3 id="项目环境搭建"><a href="#项目环境搭建" class="headerlink" title="项目环境搭建"></a>项目环境搭建</h3><h4 id="1-项目分析"><a href="#1-项目分析" class="headerlink" title="1.项目分析"></a>1.项目分析</h4><p>项目功能:登录,注册,热销商品,用户管理(密码,个人信息,头像,收货地址),购物车(展示,增加,删除),订单模块</p><p>开发顺序:注册,登录,用户管理,购物车,商品,订单模块</p><p>某一个模块的开发顺序:</p><p>持久层开发:依据前端页面的设置规划相关的SQL语句,以及进行配置</p><p>业务层开发:核心功能控制,业务操作以及异常的处理</p><p>控制层开发:接收请求,处理响应</p><p>前端开发:JS,Query,AJAX这些技术来连接后台</p><h4 id="2-项目基本环境"><a href="#2-项目基本环境" class="headerlink" title="2.项目基本环境"></a>2.项目基本环境</h4><p>JDK:1.8版本及以上<br>maven:需要配置到idea,3.6.1版本及以上<br>数据库:MySQL,要求是5.1版本及以上<br>开发的平台:Idea</p><p>项目名称:store,表示商城<br>结构:com.cy.store<br>资源文件:resources文件夹下(static,templates)<br>单元测试:test.com.cy.store</p><h4 id="3-项目创建"><a href="#3-项目创建" class="headerlink" title="3.项目创建"></a>3.项目创建</h4><p>1.Create New Project-&gt;</p><p>2.选择Spring Initializr,点击next</p><p>3.跳转到Project Metadata页面,该页面的Group填写域com和自己起的域名cy(即com.cy)==;Artifact填写项目名store;==Java Version版本选择自己安装的版本,点击next</p><p>4.选择需要导入的jar包:<br>    前后端的连接jar包:Web目录下的Spring web<br>    mybatis的jar包:SQL目录下的Mybatis Framework<br>    mysql数据库的驱动:SQL目录下的MySQL Driver</p><p>5.创建一个数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database store <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8;<br></code></pre></td></tr></table></figure><p>6.在application.properties文件中配置数据库的连接源信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/store?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/shanghai</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure><h4 id="4-项目测试"><a href="#4-项目测试" class="headerlink" title="4.项目测试"></a>4.项目测试</h4><h5 id="4-1测试能否成功连接数据库"><a href="#4-1测试能否成功连接数据库" class="headerlink" title="4.1测试能否成功连接数据库"></a>4.1测试能否成功连接数据库</h5><p>启动Springboot主类,看idea中是否有对应的spring图形输出</p><p>若idea有对应的spring图形输出开始第二步测试:在单元测试中测试数据库的连接是否可以加载:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StoreApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">//自动装配</span><br>    <span class="hljs-keyword">private</span> DataSource dataSource;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        System.out.println(dataSource.getConnection());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行getConnection方法,若成功返回HikariProxyConnection@189194499 wrapping com.mysql.cj.jdbc.ConnectionImpl@2b0e9f30则说明成功连接数据库,其中Hikari是一个连接池,用来管理数据库的连接对象,是springboot默认内部整合的连接池,该连接池号称世界上最快的连接池,底层仍然采用c3p0来管理数据库的连接对象。</p><h5 id="4-2测试静态资源能否正常加载"><a href="#4-2测试静态资源能否正常加载" class="headerlink" title="4.2测试静态资源能否正常加载"></a>4.2测试静态资源能否正常加载</h5><p>将静态资源(SpringBoot电脑商城项目-V1.0\tools\pages_src\pages*)复制到static目录下重启项目并尝试访问localhost:8080/web/login.html(因为static是默认根目录,所以不是localhost:8080/static/web/login.html)</p><p>如果这个过程访问失败,原因是idea对于JS代码的兼容性较差,编写了js代码但是有的时候不能正常去加载,解决办法有以下四种:</p><p>1.clear-install:依次点击MavenProject-&gt;store-&gt;Lifecycle-&gt;clean,等待清哩项目完毕后点击同目录下的install重新部署</p><p>2.idea缓存清理:点击File下的Invalidate Caches/Restart…然后在弹出的窗口中选择Invalidate and Restart,此时就会自动清除缓存并重新启动idea</p><p>3.rebuild重新构建:点击工具栏的Build下的Rebuild Project</p><p>4.重启电脑</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>电脑商城</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSM</tag>
      
      <tag>项目练习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客文章操作</title>
    <link href="/2023/04/23/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/04/23/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>在上一篇博客中记录了个人博客从无到有的搭建，这篇博客就来记录一下一些关于博客文章相关的操作。</p><p>首先找到自己博客所在的文件在，我的是在D:\Workspace\Myblog\hexo-blog，接着在地址框里输入cmd进入命令行窗口（或者是在该目录下右键git bash here）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">在/source/_posts目录下新建一个 文件名.md 文件，该文件就是我们用来写博客的文件。</span><br>hexo new &quot;文件名&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除博客的话直接在对应目录下删除对应的markdown文件即可。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">拓展：markdown文件中引入图片和超链接：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">![描述信息](图片名称带后缀)    图片放在和markdown文件同级目录下的同名文件夹中。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[描述信息](超链接地址)  注意英文状态</span><br></code></pre></td></tr></table></figure><p>当在本地文件夹下进行修改以后，进行如下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">清除缓存文件 (db.json) 和已生成的静态文件 (public)。</span><br>hexo clean  <br><span class="hljs-meta prompt_">#</span><span class="language-bash">是hexo generate命令的简写，生成静态文件。</span><br>hexo g     <br><span class="hljs-meta prompt_">#</span><span class="language-bash">是hexo server的简写，启动服务器。默认情况下，访问网址为：http://localhost:4000/。</span><br>hexo s     <br><span class="hljs-meta prompt_">#</span><span class="language-bash">是hexo deploy命令的简写，部署网站，同步到你的个人网站中了(博客在本机访问时不可以进行此操作，否则会报错)</span><br>hexo d      <br></code></pre></td></tr></table></figure><p>目前先总结这些常用的操作，后续会不断补充。了解更多可以参考官网：<a href="https://hexo.io/zh-cn/docs/commands.html">hexo官网</a></p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Idea中的快捷键</title>
    <link href="/2023/04/22/Idea%E4%B8%AD%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2023/04/22/Idea%E4%B8%AD%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="1-IDEA的日常快捷键"><a href="#1-IDEA的日常快捷键" class="headerlink" title="1-IDEA的日常快捷键"></a>1-IDEA的日常快捷键</h2><h3 id="第1组：通用型"><a href="#第1组：通用型" class="headerlink" title="第1组：通用型"></a>第1组：通用型</h3><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>复制代码-copy</td><td>ctrl + c</td></tr><tr><td>粘贴-paste</td><td>ctrl + v</td></tr><tr><td>剪切-cut</td><td>ctrl + x</td></tr><tr><td>撤销-undo</td><td>ctrl + z</td></tr><tr><td>反撤销-redo</td><td>ctrl + shift + z</td></tr><tr><td>保存-save all</td><td>ctrl + s</td></tr><tr><td>全选-select all</td><td>ctrl + a</td></tr></tbody></table><h3 id="第2组：提高编写速度（上）"><a href="#第2组：提高编写速度（上）" class="headerlink" title="第2组：提高编写速度（上）"></a>第2组：提高编写速度（上）</h3><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>智能提示-edit</td><td>alt + enter</td></tr><tr><td>提示代码模板-insert live template</td><td>ctrl+j</td></tr><tr><td>使用xx块环绕-surround with …</td><td>ctrl+alt+t</td></tr><tr><td>调出生成getter/setter/构造器等结构-generate …</td><td>alt+insert</td></tr><tr><td>自动生成返回值变量-introduce variable …</td><td>ctrl+alt+v</td></tr><tr><td>复制指定行的代码-duplicate line or selection</td><td>ctrl+d</td></tr><tr><td>删除指定行的代码-delete line</td><td>ctrl+y</td></tr><tr><td>切换到下一行代码空位-start new line</td><td>shift + enter</td></tr><tr><td>切换到上一行代码空位-start new line before current</td><td>ctrl +alt+ enter</td></tr><tr><td>向上移动代码-move statement up</td><td>ctrl+shift+↑</td></tr><tr><td>向下移动代码-move statement down</td><td>ctrl+shift+↓</td></tr><tr><td>向上移动一行-move line up</td><td>alt+shift+↑</td></tr><tr><td>向下移动一行-move line down</td><td>alt+shift+↓</td></tr><tr><td>方法的形参列表提醒-parameter info</td><td>ctrl+p</td></tr></tbody></table><h3 id="第3组：提高编写速度（下）"><a href="#第3组：提高编写速度（下）" class="headerlink" title="第3组：提高编写速度（下）"></a>第3组：提高编写速度（下）</h3><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>批量修改指定的变量名、方法名、类名等-rename</td><td>shift+f6</td></tr><tr><td>抽取代码重构方法-extract method …</td><td>ctrl+alt+m</td></tr><tr><td>重写父类的方法-override methods …</td><td>ctrl+o</td></tr><tr><td>实现接口的方法-implements methods …</td><td>ctrl+i</td></tr><tr><td>选中的结构的大小写的切换-toggle case</td><td>ctrl+shift+u</td></tr><tr><td>批量导包-optimize imports</td><td>ctrl+alt+o</td></tr></tbody></table><h3 id="第4组：类结构、查找和查看源码"><a href="#第4组：类结构、查找和查看源码" class="headerlink" title="第4组：类结构、查找和查看源码"></a>第4组：类结构、查找和查看源码</h3><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>如何查看源码-go to class…</td><td>ctrl + 选中指定的结构 或 ctrl+n</td></tr><tr><td>显示当前类结构，支持搜索指定的方法、属性等-file structure</td><td>ctrl+f12</td></tr><tr><td>退回到前一个编辑的页面-back</td><td>ctrl+alt+←</td></tr><tr><td>进入到下一个编辑的页面-forward</td><td>ctrl+alt+→</td></tr><tr><td>打开的类文件之间切换-select previous/next tab</td><td>alt+←/→</td></tr><tr><td>光标选中指定的类，查看继承树结构-Type Hierarchy</td><td>ctrl+h</td></tr><tr><td>查看方法文档-quick documentation</td><td>ctrl+q</td></tr><tr><td>类的UML关系图-show uml popup</td><td>ctrl+alt+u</td></tr><tr><td>定位某行-go to line/column</td><td>ctrl+g</td></tr><tr><td>回溯变量或方法的来源-go to implementation(s)</td><td>ctrl+alt+b</td></tr><tr><td>折叠方法实现-collapse all</td><td>ctrl+shift+ -</td></tr><tr><td>展开方法实现-expand all</td><td>ctrl+shift+ +</td></tr><tr><td>查看当前类结构</td><td>alt+7</td></tr></tbody></table><h3 id="第5组：查找、替换与关闭"><a href="#第5组：查找、替换与关闭" class="headerlink" title="第5组：查找、替换与关闭"></a>第5组：查找、替换与关闭</h3><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>查找指定的结构</td><td>ctlr+f</td></tr><tr><td>快速查找：选中的Word快速定位到下一个-find next</td><td>ctrl+l</td></tr><tr><td>查找与替换-replace</td><td>ctrl+r</td></tr><tr><td>直接定位到当前行的首位-move caret to line start</td><td>home</td></tr><tr><td>直接定位到当前行的末位 -move caret to line end</td><td>end</td></tr><tr><td>查询当前元素在当前文件中的引用，然后按 F3 可以选择</td><td>ctrl+f7</td></tr><tr><td>全项目搜索文本-find in path …</td><td>ctrl+shift+f</td></tr><tr><td>关闭当前窗口-close</td><td>ctrl+f4</td></tr></tbody></table><h3 id="第6组：调整格式"><a href="#第6组：调整格式" class="headerlink" title="第6组：调整格式"></a>第6组：调整格式</h3><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>格式化代码-reformat code</td><td>ctrl+alt+l</td></tr><tr><td>使用单行注释-comment with line comment</td><td>ctrl + /</td></tr><tr><td>使用/取消多行注释-comment with block comment</td><td>ctrl + shift + /</td></tr><tr><td>选中数行，整体往后移动-tab</td><td>tab</td></tr><tr><td>选中数行，整体往前移动-prev tab</td><td>shift + tab</td></tr></tbody></table><h2 id="2-Debug快捷键"><a href="#2-Debug快捷键" class="headerlink" title="2-Debug快捷键"></a>2-Debug快捷键</h2><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>单步调试（不进入函数内部）- step over</td><td>F8</td></tr><tr><td>单步调试（进入函数内部）- step into</td><td>F7</td></tr><tr><td>强制单步调试（进入函数内部） - force step into</td><td>alt+shift+f7</td></tr><tr><td>选择要进入的函数 - smart step into</td><td>shift + F7</td></tr><tr><td>跳出函数 - step out</td><td>shift + F8</td></tr><tr><td>运行到断点 - run to cursor</td><td>alt + F9</td></tr><tr><td>继续执行，进入下一个断点或执行完程序 - resume program</td><td>F9</td></tr><tr><td>停止 - stop</td><td>Ctrl+F2</td></tr><tr><td>查看断点 - view breakpoints</td><td>Ctrl+Shift+F8</td></tr><tr><td>关闭 - close</td><td>Ctrl+F4</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 编程工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客</title>
    <link href="/2023/04/21/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/04/21/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="GitHub-Pages-Hexo搭建个人博客"><a href="#GitHub-Pages-Hexo搭建个人博客" class="headerlink" title="GitHub Pages + Hexo搭建个人博客"></a>GitHub Pages + Hexo搭建个人博客</h3><h4 id="第一步：准备工作"><a href="#第一步：准备工作" class="headerlink" title="第一步：准备工作"></a>第一步：准备工作</h4><h5 id="1-GitHub账号"><a href="#1-GitHub账号" class="headerlink" title="1.GitHub账号"></a>1.GitHub账号</h5><p>需要有一个GitHub账号，没有的话到官网申请一个。</p><h5 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h5><p>在自己电脑上安装好Git，hexo部署到GitHub时要用。</p><h5 id="3-安装NodeJS"><a href="#3-安装NodeJS" class="headerlink" title="3.安装NodeJS"></a>3.安装NodeJS</h5><p>在自己电脑上安装好NodeJS，Hexo是基于NodeJS编写的，所以需要安装NodeJS和npm工具。</p><h4 id="第二步：创建仓库"><a href="#第二步：创建仓库" class="headerlink" title="第二步：创建仓库"></a>第二步：创建仓库</h4><p>在<code>GitHub</code>上创建一个新的代码仓库用于保存我们的网页。</p><p>首先登录我们自己的GitHub账号。进行如下操作：</p><p><img src="p1.png" alt="创建仓库第1步"></p><p>点击<code>New</code>按钮，进入仓库创建页面。</p><p><img src="p2.png" alt="创建仓库第2步"></p><p>填写仓库名，格式必须为<code>&lt;用户名&gt;.github.io</code>，然后点击<code>Create repository</code>。</p><p><img src="p3.png" alt="创建仓库第3步"></p><p>点击<code>creating a new file</code>创建一个新文件，作为我们网站的主页。</p><p><img src="p4.png" alt="创建仓库第4步"></p><p>新文件的名字必须为<code>index.html</code>，内容先随便写一个简单的，内容示例如下，填写之后点击<code>Commit new file</code>提交。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>yaorongke<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>yaorongke的个人主页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello ~<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="p5.png" alt="创建仓库第5步"></p><p>GitHub Pages中找到我们主页的地址</p><p><img src="p6.png" alt="创建仓库第6步"></p><p>浏览器中访问上述地址，成功即可。当然这里创建的网页是非常简陋的，只是为了演示下<code>GitHub Pages</code>的使用方式。</p><h4 id="第三步：安装hexo"><a href="#第三步：安装hexo" class="headerlink" title="第三步：安装hexo"></a>第三步：安装hexo</h4><p>我们采用<code>Hexo</code>来创建我们的博客网站，<code>Hexo</code> 是一个基于<code>NodeJS</code>的静态博客网站生成器，使用<code>Hexo</code>不需开发，只要进行一些必要的配置即可生成一个个性化的博客网站，非常方便。点击进入<a href="https://hexo.io/zh-cn/">官网</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">安装hexo<br>npm install -g hexo-cli<br>查看版本<br>hexo -v<br>创建一个项目 hexo-blog 并初始化<br>hexo init hexo-blog<br>cd hexo-blog<br>npm install<br>本地启动<br>hexo g<br>hexo server<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000，页面默认主图风格如下">http://localhost:4000，页面默认主图风格如下</a></p><p><img src="p7.png" alt="默认风格"></p><h4 id="第四步：更换主题"><a href="#第四步：更换主题" class="headerlink" title="第四步：更换主题"></a>第四步：更换主题</h4><p><code>Hexo</code> 默认的主题不太好看，不过官方提供了数百种主题供用户选择，可以根据个人喜好更换，官网主题点 <a href="https://hexo.io/themes/">这里</a> 查看。这里以 <code>Fluid</code>为基础进行讲解的。</p><p>以下安装步骤摘自 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid官网</a></p><h5 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a><strong>安装主题</strong></h5><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a> 解压到 <code>themes</code> 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><h5 id="指定主题"><a href="#指定主题" class="headerlink" title="指定主题"></a><strong>指定主题</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">如下修改 Hexo 博客目录中的 _config.yml：<br>theme: fluid  # 指定主题<br>language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改<br>创建「关于页」<br>首次使用主题的「关于页」需要手动创建：<br>hexo new page about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。修改后的文件示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2020-02-23 19:20:33</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br><br></code></pre></td></tr></table></figure><p><strong>本地启动</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g -d</span><br><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000，`Fluid`主题风格页面如下">http://localhost:4000，`Fluid`主题风格页面如下</a></p><p><img src="p8.png" alt="fluid主题风格"></p><h4 id="第五步：创建文章"><a href="#第五步：创建文章" class="headerlink" title="第五步：创建文章"></a>第五步：创建文章</h4><p>如下修改 Hexo 博客目录中的 <code>_config.yml</code>，打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">post_asset_folder: true<br>执行如下命令创建一篇新文章，名为《测试文章》<br>hexo new post 测试文章<br><br></code></pre></td></tr></table></figure><p>执行完成后在<code>source\_posts</code>目录下生成了一个md文件和一个同名的资源目录(用于存放图片)</p><p><img src="p9.png" alt="`source\_posts`目录下生成了一个md文件和一个同名的资源目录"></p><p>图片的引入方式可参考官方文档 <a href="https://hexo.io/zh-cn/docs/asset-folders.html%EF%BC%8C%E6%9C%89%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E3%80%82%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E5%86%8D%E6%BC%94%E7%A4%BA%E3%80%82">https://hexo.io/zh-cn/docs/asset-folders.html，有详细介绍。这里就不再演示。</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">测试文章</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2021-06-10 16:35:20</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">原创</span><br><span class="hljs-attr">categories:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Java</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这是一篇测试文章</span><br><br>&#123;<span class="hljs-string">%</span> <span class="hljs-string">asset_img</span> <span class="hljs-string">test.png</span> <span class="hljs-string">图片引用方法一</span> <span class="hljs-string">%</span>&#125;<br><br><span class="hljs-type">![</span><span class="hljs-string">图片引用方法二](test.png)</span><br><br><span class="hljs-type">![</span><span class="hljs-string">图片引用方法三](/images/test.png)</span><br><br></code></pre></td></tr></table></figure><h4 id="第六步：个性化页面展示"><a href="#第六步：个性化页面展示" class="headerlink" title="第六步：个性化页面展示"></a>第六步：个性化页面展示</h4><p>该部分因个人喜好而定，因为我本人也是参照的官方用户手册，就不再赘述。<a href="https://fluid-dev.github.io/hexo-fluid-docs/start/">文档地址</a></p><h4 id="第七步：发布到githu-Pages"><a href="#第七步：发布到githu-Pages" class="headerlink" title="第七步：发布到githu Pages"></a>第七步：发布到githu Pages</h4><p>安装hexo-deployer-git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>修改根目录下的 <code>_config.yml</code>，配置 <code>GitHub</code> 相关信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">deploy:<br>  type: git<br>  repo: https://github.com/yaorongke/yaorongke.github.io.git<br>  branch: main<br>  token: ghp_3KakcaPHerunNRyMerofcFd9pblU282FSbsY<br></code></pre></td></tr></table></figure><p>其中 <code>token</code> 为 <code>GitHub</code> 的 <code>Personal access tokens</code>，获取方式如下图</p><p><img src="p10.png" alt="获取token"></p><p>部署到Github</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br></code></pre></td></tr></table></figure><p>浏览器访问 https://用户名.github.io/，部署成功</p><h4 id="个人博客的搭建及本片博客的编写参照了csdn“淡淡的说非”的博客《GitHub-Pages-Hexo搭建个人博客网站，史上最全教程》地址"><a href="#个人博客的搭建及本片博客的编写参照了csdn“淡淡的说非”的博客《GitHub-Pages-Hexo搭建个人博客网站，史上最全教程》地址" class="headerlink" title="个人博客的搭建及本片博客的编写参照了csdn“淡淡的说非”的博客《GitHub Pages + Hexo搭建个人博客网站，史上最全教程》地址"></a>个人博客的搭建及本片博客的编写参照了csdn“淡淡的说非”的博客《GitHub Pages + Hexo搭建个人博客网站，史上最全教程》<a href="https://blog.csdn.net/yaorongke/article/details/119089190">地址</a></h4>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2023/04/20/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2023/04/20/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><img src="/2023/04/20/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.png" class="" title="图片引用方法一"><p><img src="test.png" alt="图片引用方法二"></p><p><img src="/images/test.png" alt="图片引用方法三"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
